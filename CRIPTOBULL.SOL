/**	
CRIPTOBULL ** 
 */	
pragma solidez ^0. 8. 4;	
SpDX-Identificador de licença: sem licença 
interface IBEP20 {	
    total de funçãoSupply() retornos de visão externa (uint256);	
    /**	
 * @dev Devolve a quantidade de tokens de propriedade da 'conta'. 
     */	
     balance de funçãoDe (contade endereço ) retornos de visualização externa (uint256);	
    /**	
 * @dev move tokens de 'quantidade' da conta do chamador para 'destinatário'. 
     *	
 * Retorna um valor booleano indicando se a operação foi bem sucedida. 
     *	
 * Emite um evento {Transfer}. 
     */	
     transferência defunção (destinatáriode endereços , valor uint256 ) retornos externos  (bool);	
    /**	
 * @dev Retorna o número restante de tokens que 'gastador' serão 
 * permitido gastar em nome do 'proprietário' através de {transferFrom}. Isso é 
 * zero por padrão. 
     *	
 * Este valor muda quando {approve} ou {transferFrom} são chamados. 
     */	
     subsídio defunção (proprietário deendereço , gastador de endereço ) retornos de visão externa (uint256);	
    /**	
 * @dev Define 'valor' como a mesada do 'gastador' sobre os tokens do chamador. 
     *	
 * Retorna um valor booleano indicando se a operação foi bem sucedida. 
     *	
 * IMPORTANTE: Cuidado que a mudança de subsídio com este método traz o risco 
 * que alguém pode usar tanto o velho quanto o novo subsídio por infeliz 
 * encomenda de transação. Uma possível solução para mitigar esta corrida 
 * condição é primeiro reduzir o subsídio do gastador para 0 e definir o 
 * valor desejado depois: 
 https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 
     *	
 * Emite um evento {Approval}. 
     */	
    função aprovar (gastadorde endereços , uint256 valor) retornos externos  (bool);	
    /**	
 * @dev move tokens 'de quantidade' de 'remetente' para 'destinatário' usando o 
 * mecanismo de subsídio. 'quantidade' é então deduzida do chamador 
 * subsídio. 
     *	
 * Retorna um valor booleano indicando se a operação foi bem sucedida. 
     *	
 * Emite um evento {Transfer}. 
     */	
     transferência de funçãoDe (remetente deendereço, destinatário de endereços, quantidade uint256 ) retornos externos  (bool);	
    /**	
 * @dev Emitidos quando tokens 'valor' são movidos de uma conta ('de') para 
 * outro ('to'). 
     *	
 * Observe que o 'valor' pode ser zero. 
     */	
     transferênciade eventos(endereço indexado a, endereço indexado a, uint256 valor);	
    /**	
 * @dev Emitido quando a mesada de um 'gastador' para um 'proprietário' é definida por 
 * uma chamada para {approve}. 'valor' é o novo subsídio. 
     */	
     aprovação doevento( proprietário indexado deendereço, gasto indexado  de endereço, valor uint256);	
}	
/**	
 * @dev Wrappers sobre as operações aritméticas da Solidity com um estouro adicional 
 * cheques. 
 *	
 * Operações aritméticas em Solidity envolvem o transbordamento. Isso pode facilmente resultar 
 * em bugs, porque os programadores geralmente assumem que um transbordamento levanta um 
 * erro, que é o comportamento padrão em linguagens de programação de alto nível. 
 * 'SafeMath' restaura essa intuição revertendo a transação quando um 
 * operação transborda. 
 *	
 * O uso desta biblioteca em vez das operações não verificadas elimina um todo 
 * classe de insetos, por isso é recomendado usá-lo sempre. 
 */	
 	
biblioteca SafeMath {	
    /**	
 * @dev Retorna a adição de dois inteiros não assinados, revertendo em 
 * transbordar. 
     *	
 * Contrapartida ao operador '+' da Solidity. 
     *	
 * Requisitos: 
     *	
 * - A adição não pode transbordar. 
     */	
    adicionar função(uint256 a, uint256 b) retornos puros internos (uint256) {	
        uint256 c = a + b;	
        exigir(c >= a, "SafeMath: adição de estouro");	
        retorno c; 
    }	
    /**	
 * @dev Retorna a subtração de dois inteiros não assinados, revertendo em 
 * estouro (quando o resultado é negativo). 
     *	
 * Contrapartida ao operador '-' da Solidity. 
     *	
 * Requisitos: 
     *	
 * - A subtração não pode transbordar. 
     */	
     função sub(uint256 a, uint256 b) retornos puros internos (uint256) {	
        sub de retorno (a,b, "SafeMath: subtração estouro");	
    }	
    /**	
 * @dev Retorna a subtração de dois inteiros não assinados, revertendo com mensagem personalizada em 
 * estouro (quando o resultado é negativo). 
     *	
 * Contrapartida ao operador '-' da Solidity. 
     *	
 * Requisitos: 
     *	
 * - A subtração não pode transbordar. 
     */	
     função sub(uint256 a, uint256 b, erro de memória de sequência de caracteresage ) retornos puros internos  (uint256) {	
        exigir(b <= a, erroMessage); 
        uint256 c = a - b;	
        retorno c; 
    }	
    /**	
 * @dev Retorna a multiplicação de dois inteiros não assinados, revertendo em 
 * transbordar. 
     *	
 * Contrapartida ao operador '*' da Solidity. 
     *	
 * Requisitos: 
     *	
 * - A multiplicação não pode transbordar. 
     */	
    função mul(uint256 a, uint256 b) retornos puros internos (uint256) {	
        Otimização de gás: isso é mais barato do que exigir 'a' não ser zero, mas o 
        benefício é perdido se 'b' também for testado. 
        Veja: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 
        se (a == 0) {	
            retorno 0;	
        }	
        uint256 c = a * b;	
        requerem(c / a == b, "SafeMath: multiplicação de transbordamento");	
        retorno c; 
    }	
    /**	
 * @dev Retorna a divisão de inteiros de dois inteiros não assinados. Reverte em 
 * divisão por zero. O resultado é arredondado para zero. 
     *	
 * Contrapartida ao operador '/' da Solidity. Nota: esta função usa um 
 * 'reverter' opcode (que deixa o gás restante intocado) enquanto Solidity 
 * usa um opcode inválido para reverter (consumindo todo o gás restante). 
     *	
 * Requisitos: 
     *	
 * - O divisor não pode ser zero. 
     */	
     divfunção(uint256 a, uint256 b) retornos puros internos (uint256) {	
         divde retorno (a, b, "SafeMath: divisão por zero");	
    }	
    /**	
 * @dev Retorna a divisão de inteiros de dois inteiros não assinados. Reverte com mensagem personalizada em 
 * divisão por zero. O resultado é arredondado para zero. 
     *	
 * Contrapartida ao operador '/' da Solidity. Nota: esta função usa um 
 * 'reverter' opcode (que deixa o gás restante intocado) enquanto Solidity 
 * usa um opcode inválido para reverter (consumindo todo o gás restante). 
     *	
 * Requisitos: 
     *	
 * - O divisor não pode ser zero. 
     */	
     divfunção(uint256 a, uint256 b, erro de memória de sequência de caracteres) retornos puros internos   (uint256) {	
        exigir(b > 0, erroMessage); 
        uint256 c = a / b;	
        assert(a == b * c + a % b); Não há nenhum caso em que isso não se mantém 
        retorno c; 
    }	
    /**	
 * @dev Retorna o restante da divisão de dois inteiros não assinados. (modulo inteiro não assinado), 
 * Reverte ao dividir por zero. 
     *	
 * Contrapartida ao operador '%' da Solidity. Esta função usa um 'reverso' 
 * opcode (que deixa o gás restante intocado) enquanto solidez usa um 
 * opcode inválido para reverter (consumindo todo o gás restante). 
     *	
 * Requisitos: 
     *	
 * - O divisor não pode ser zero. 
     */	
    função mod(uint256 a, uint256 b) retornos puros internos (uint256) {	
        retorno mod(a, b, "SafeMath: modulo por zero");	
    }	
    /**	
 * @dev Retorna o restante da divisão de dois inteiros não assinados. (modulo inteiro não assinado), 
 * Reverte com mensagem personalizada ao dividir por zero. 
     *	
 * Contrapartida ao operador '%' da Solidity. Esta função usa um 'reverso' 
 * opcode (que deixa o gás restante intocado) enquanto solidez usa um 
 * opcode inválido para reverter (consumindo todo o gás restante). 
     *	
 * Requisitos: 
     *	
 * - O divisor não pode ser zero. 
     */	
     função mod(uint256 a, uint256 b, erro de memória de sequência Deserdação) retornos puros  internos (uint256) {	
        exigir(b != 0, erroMessage); 
        retornar a % b; 
    }	
}	
 contexto de contrato abstrato {	
    função _msgSender() retornos virtuais de visualização interna (endereço) {	
        retorno msg. remetente;	
    }	
    função _msgData() retornos virtuais de visualização interna (memória bytes) {	
        isso; // aviso de mutabilidade do estado de silêncio sem gerar bytecode - veja https://github.com/ethereum/solidity/issues/2691
        retorno msg. dados;	
    }	
}	
/**	
 * @dev Coleta de funções relacionadas ao tipo de endereço 
 */	
Endereço da biblioteca {	
    /**	
 * @dev Retornos verdadeiros se 'conta' for um contrato. 
     *	
 * [IMPORTANTE] 
     * ====	
 * Não é seguro assumir que um endereço para o qual esta função retorna 
 * falso é uma conta de propriedade externa (EOA) e não um contrato. 
     *	
 * Entre outros, 'isContract' retornará falso para o seguinte 
 * tipos de endereços: 
     *	
 * - uma conta de propriedade externa 
 * - um contrato na construção 
 * - um endereço onde um contrato será criado 
 um endereço onde um contrato vivia, mas foi destruído 
     * ====	
     */	
    função isContract (contade endereço ) retornos de visualização interna (bool) {	
        De acordo com o EIP-1052, 0x0 é o valor devolvido para contas ainda não criadas 
        e 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 é devolvido 
        para contas sem código, ou seja, 'keccak256('')' 
        bytes32 codehash;	
        bytes32 contaHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;	
        solhint-desativar-próxima-linha não-inline-montagem 
 montagem { codehash := extcodehash(conta) } 
        retorno (codehash != contaHash && codehash != 0x0);	
    }	
    /**	
 * @dev substituição para a 'transferência' da Solidity: envia 'quantia' wei para 
 * 'destinatário', encaminhando todo o gás disponível e revertendo erros. 
     *	
 * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] aumenta o custo do gás 
 * de certos opcodes, possivelmente fazendo contratos ultrapassarem o limite de 2300 gás 
 * imposta por 'transferência', tornando-os incapazes de receber fundos via 
 * 'transferência'. {sendValue} remove essa limitação. 
     *	
 * https://diligence.consensys.net/posts/2019/09/stop-uso-solidezs-transferência-agora/[Saiba mais]. 
     *	
 * IMPORTANTE: como o controle é transferido para 'receptor', o cuidado deve ser 
 * tomado para não criar vulnerabilidades de reentrada. Considere usar 
 * {ReentrancyGuard} ou o 
 * https://solidity.readthedocs.io/en/v0.5.11/security-considerações.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern]. 
     */	
    função sendValue (destinatárioa pagar endereço , valor uint256 ) interno {	
        exigir(endereço(este.saldo >= quantidade, "Endereço: saldo insuficiente");	
        solhint-desativar-próxima-linha evitar-chamadas de nível baixo, evitar-chamada-valor 
        (bool success, ) = recipient.call{ valor: valor }("");	
        exigir(sucesso, "Endereço: incapaz de enviar valor, destinatário pode ter revertido");	
    }	
    /**	
 * @dev executa uma chamada de função Solidity usando uma 'chamada' de baixo nível. Um 
 * plain 'call' é um substituto inseguro para uma chamada de função: use este 
 * função em vez disso. 
     *	
 * Se 'alvo' reverte com uma razão de reverter, ele é borbulhado por este 
 * função (como chamadas regulares da função Solidity). 
     *	
 * Retorna os dados devolvidos brutos. Para converter para o valor de retorno esperado, 
 * use https://solidity.readthedocs.io/en/latest/units e global-variáveis.html?highlight=abi.decode#abi-encoding-and-decoding-functions['abi.decode']. 
     *	
 * Requisitos: 
     *	
 * - 'alvo' deve ser um contrato. 
 * - chamar 'alvo' com 'dados' não deve reverter. 
     *	
 _Available desde v3.1._ 
     */	
     função funçãoCall (alvode endereço , bytes dados de memória ) retornos internos (bytes memória) {	
      função de retornoCham(alvo, dados,  "Endereço: falha de chamada de baixo nível");	
    }	
    /**	
 * @dev Mesmo que {xref-Address-functionCall-address-bytes-}['functionCall'], mas com 
 * 'errorMessage' como uma razão de reversão de recuo quando 'alvo' reverte. 
     *	
 _Available desde v3.1._ 
     */	
     função funçãoCall (alvode endereço, bytes dados de memória, erro de memória de seqüênciaSsagem ) retornos internos  (bytes memória) {	
        _functionCallWithValue de retorno (alvo,dados, 0, erroMessage); 
    }	
    /**	
 * @dev Mesmo que {xref-Address-functionCall-address-bytes-}['functionCall'], 
 * mas também transferindo 'valor' wei para 'target'. 
     *	
 * Requisitos: 
     *	
 * - o contrato de chamada deve ter um saldo ETH de pelo menos 'valor'. 
 * - a chamada função Solidity deve ser 'pagável'. 
     *	
 _Available desde v3.1._ 
     */	
     função funçãoCallWithValue (alvode endereço , bytes dados de memória , uint256 valor) retornos internos  (bytes memória) {	
        função de retornoCallWithValue(alvo, dados, valor, "Endereço: chamada de baixo nível com falha de valor" );	
    }	
    /**	
 * @dev Mesmo que {xref-Address-functionCallWithValue-address-bytes-uint256-}['functionCallWithValue'], mas 
 * com 'errorMessage' como uma razão de retrocesso quando 'alvo' reverte. 
     *	
 _Available desde v3.1._ 
     */	
     função funçãoCallWithValue (alvode endereço, bytes dados de memória , uint256 valor, erro de memória de seqüênciaMessage ) retornos internos  (bytes memória) {	
        exigir(endereço(este.balance >= valor, "Endereço: saldo insuficiente para chamada");	
        _functionCallWithValue de retorno (alvo,dados, valor, erroMessage); 
    }	
    função _functionCallWithValue (alvode endereço, bytes dados de memória , uint256 weiValue, erro de memória de seqüênciaSsagem) retornos privados(bytes memória ) {	
        exigir(isContract(alvo), "Endereço: chamada para não-contrato");	
        solhint-desativar-próxima-linha evitar-baixo nível-chamadas 
        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);	
        se (sucesso) { 
            dados de retorno de retorno; 
        } mais {	
            Procure reverter a razão e borbulhá-la se estiver presente 
            se (dados de retorno. comprimento > 0) {	
                // The easiest way to bubble the revert reason is using memory via assembly	
                // solhint-disable-next-line no-inline-assembly	
                assembly {	
                    let returndata_size := mload(returndata)	
                    revert(add(32, returndata), returndata_size)	
                }	
            } else {	
                revert(errorMessage);	
            }	
        }	
    }	
}	
/**	
 * @dev Contract module which provides a basic access control mechanism, where	
 * there is an account (an owner) that can be granted exclusive access to	
 * specific functions.	
 *	
 * By default, the owner account will be the one that deploys the contract. This	
 * can later be changed with {transferOwnership}.	
 *	
 * This module is used through inheritance. It will make available the modifier	
 * `onlyOwner`, which can be applied to your functions to restrict their use to	
 * the owner.	
 */	
contract Ownable is Context {	
    address private _owner;	
    address private _previousOwner;	
    uint256 private _lockTime;	
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);	
    /**	
     * @dev Initializes the contract setting the deployer as the initial owner.	
     */	
    constructor () {	
        address msgSender = _msgSender();	
        _owner = msgSender;	
        emit OwnershipTransferred(address(0), msgSender);	
    }	
    /**	
     * @dev Returns the address of the current owner.	
     */	
    function owner() public view returns (address) {	
        return _owner;	
    }	
    /**	
     * @dev Throws if called by any account other than the owner.	
     */	
    modifier onlyOwner() {	
        require(_owner == _msgSender(), "Ownable: caller is not the owner");	
        _;	
    }	
     /**	
     * @dev Leaves the contract without owner. It will not be possible to call	
     * `onlyOwner` functions anymore. Can only be called by the current owner.	
     *	
     * NOTE: Renouncing ownership will leave the contract without an owner,	
     * thereby removing any functionality that is only available to the owner.	
     */	
    function renounceOwnership() public virtual onlyOwner {	
        emit OwnershipTransferred(_owner, address(0));	
        _owner = address(0);	
    }	
    /**	
     * @dev Transfers ownership of the contract to a new account (`newOwner`).	
     * Can only be called by the current owner.	
     */	
    function transferOwnership(address newOwner) public virtual onlyOwner {	
        require(newOwner != address(0), "Ownable: new owner is the zero address");	
        emit OwnershipTransferred(_owner, newOwner);	
        _owner = newOwner;	
    }	
    function geUnlockTime() public view returns (uint256) {	
        return _lockTime;	
    }	
    //Locks the contract for owner for the amount of time provided	
    function lock(uint256 time) public virtual onlyOwner {	
        _previousOwner = _owner;	
        _owner = address(0);	
        _lockTime = block.timestamp + time;	
        emit OwnershipTransferred(_owner, address(0));	
    }	
    	
    //Unlocks the contract for owner when _lockTime is exceeds	
    function unlock() public virtual {	
        require(_previousOwner == msg.sender, "You don't have permission to unlock");	
        require(block.timestamp > _lockTime , "Contract is locked until 7 days");	
        emit OwnershipTransferred(_owner, _previousOwner);	
        _owner = _previousOwner;	
    }	
}	
// pragma solidity >=0.5.0;	
interface IUniswapV2Factory {	
    event PairCreated(address indexed token0, address indexed token1, address pair, uint);	
    function feeTo() external view returns (address);	
    function feeToSetter() external view returns (address);	
    function getPair(address tokenA, address tokenB) external view returns (address pair);	
    function allPairs(uint) external view returns (address pair);	
    function allPairsLength() external view returns (uint);	
    function createPair(address tokenA, address tokenB) external returns (address pair);	
    function setFeeTo(address) external;	
    function setFeeToSetter(address) external;	
}	
// pragma solidity >=0.5.0;	
interface IUniswapV2Pair {	
    event Approval(address indexed owner, address indexed spender, uint value);	
    event Transfer(address indexed from, address indexed to, uint value);	
    function name() external pure returns (string memory);	
    function symbol() external pure returns (string memory);	
    function decimals() external pure returns (uint8);	
    function totalSupply() external view returns (uint);	
    function balanceOf(address owner) external view returns (uint);	
    function allowance(address owner, address spender) external view returns (uint);	
    function approve(address spender, uint value) external returns (bool);	
    function transfer(address to, uint value) external returns (bool);	
    function transferFrom(address from, address to, uint value) external returns (bool);	
    function DOMAIN_SEPARATOR() external view returns (bytes32);	
    function PERMIT_TYPEHASH() external pure returns (bytes32);	
    function nonces(address owner) external view returns (uint);	
    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;	
    event Mint(address indexed sender, uint amount0, uint amount1);	
    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);	
    event Swap(	
        address indexed sender,	
        uint amount0In,	
        uint amount1In,	
        uint amount0Out,	
        uint amount1Out,	
        address indexed to	
    );	
    event Sync(uint112 reserve0, uint112 reserve1);	
    function MINIMUM_LIQUIDITY() external pure returns (uint);	
    function factory() external view returns (address);	
    function token0() external view returns (address);	
    function token1() external view returns (address);	
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);	
    function price0CumulativeLast() external view returns (uint);	
    function price1CumulativeLast() external view returns (uint);	
    function kLast() external view returns (uint);	
    function mint(address to) external returns (uint liquidity);	
    function burn(address to) external returns (uint amount0, uint amount1);	
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;	
    function skim(address to) external;	
    function sync() external;	
    function initialize(address, address) external;	
}	
// pragma solidity >=0.6.2;	
interface IUniswapV2Router01 {	
    function factory() external pure returns (address);	
    function WETH() external pure returns (address);	
    function addLiquidity(	
        address tokenA,	
        address tokenB,	
        uint amountADesired,	
        uint amountBDesired,	
        uint amountAMin,	
        uint amountBMin,	
        address to,	
        uint deadline	
    ) external returns (uint amountA, uint amountB, uint liquidity);	
    function addLiquidityETH(	
        address token,	
        uint amountTokenDesired,	
        uint amountTokenMin,	
        uint amountETHMin,	
        address to,	
        uint deadline	
    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);	
    function removeLiquidity(	
        address tokenA,	
        address tokenB,	
        uint liquidity,	
        uint amountAMin,	
        uint amountBMin,	
        address to,	
        uint deadline	
    ) external returns (uint amountA, uint amountB);	
    function removeLiquidityETH(	
        address token,	
        uint liquidity,	
        uint amountTokenMin,	
        uint amountETHMin,	
        address to,	
        uint deadline	
    ) external returns (uint amountToken, uint amountETH);	
    function removeLiquidityWithPermit(	
        address tokenA,	
        address tokenB,	
        uint liquidity,	
        uint amountAMin,	
        uint amountBMin,	
        address to,	
        uint deadline,	
        bool approveMax, uint8 v, bytes32 r, bytes32 s	
    ) external returns (uint amountA, uint amountB);	
    function removeLiquidityETHWithPermit(	
        address token,	
        uint liquidity,	
        uint amountTokenMin,	
        uint amountETHMin,	
        address to,	
        uint deadline,	
        bool approveMax, uint8 v, bytes32 r, bytes32 s	
    ) external returns (uint amountToken, uint amountETH);	
    function swapExactTokensForTokens(	
        uint amountIn,	
        uint amountOutMin,	
        address[] calldata path,	
        address to,	
        uint deadline	
    ) external returns (uint[] memory amounts);	
    function swapTokensForExactTokens(	
        uint amountOut,	
        uint amountInMax,	
        address[] calldata path,	
        address to,	
        uint deadline	
    ) external returns (uint[] memory amounts);	
    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)	
        external	
        payable	
        returns (uint[] memory amounts);	
    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)	
        external	
        returns (uint[] memory amounts);	
    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)	
        external	
        returns (uint[] memory amounts);	
    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)	
        external	
        payable	
        returns (uint[] memory amounts);	
    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);	
    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);	
    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);	
    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);	
    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);	
}	
// pragma solidity >=0.6.2;	
interface IUniswapV2Router02 is IUniswapV2Router01 {	
    function removeLiquidityETHSupportingFeeOnTransferTokens(	
        address token,	
        uint liquidity,	
        uint amountTokenMin,	
        uint amountETHMin,	
        address to,	
        uint deadline	
    ) external returns (uint amountETH);	
    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(	
        address token,	
        uint liquidity,	
        uint amountTokenMin,	
        uint amountETHMin,	
        address to,	
        uint deadline,	
        bool approveMax, uint8 v, bytes32 r, bytes32 s	
    ) external returns (uint amountETH);	
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(	
        uint amountIn,	
        uint amountOutMin,	
        address[] calldata path,	
        address to,	
        uint deadline	
    ) external;	
    function swapExactETHForTokensSupportingFeeOnTransferTokens(	
        uint amountOutMin,	
        address[] calldata path,	
        address to,	
        uint deadline	
    ) external payable;	
    function swapExactTokensForETHSupportingFeeOnTransferTokens(	
        uint amountIn,	
        uint amountOutMin,	
        address[] calldata path,	
        address to,	
        uint deadline	
    ) external;	
}	
contract CRIPTOBULL is Context, IBEP20, Ownable {	
    using SafeMath for uint256;	
    using Address for address;	
    mapping (address => uint256) private _rOwned;	
    mapping (address => uint256) private _tOwned;	
    mapping (address => mapping (address => uint256)) private _allowances;	
    mapping (address => bool) private _isExcludedFromFee;	
    mapping (address => bool) private _isExcluded;	
    mapping (address => bool) public _isExcludedFromAntiWhale;
    mapping (address => bool) private _AddressExists;
    address[] private _addressList;
    address[] private _excluded;
   	
   	address payable private _devWallet;
   	address private _lottoPotAddress;
   	address private _lottoWalletAddress;
   	uint256 public _lastLottoWinnerAmount;
    uint256 public _totalLottoPrize;
    uint public _lottoDrawCount = 0;
   
   	uint256 private _minLottoBalance = 1000000000 * 10**9;
   	
   	
    uint256 private constant MAX = ~uint256(0);	
    uint256 private _tTotal = 100000 * 10**12 * 10**9;  	   
    uint256 private _rTotal = (MAX - (MAX % _tTotal));	
    
    uint256 private _tFeeTotal;	
    string private _name = "CRIPTOBULL";	
    string private _symbol = "BULL";
    uint8 private _decimals = 18;	
    	
    uint256 public _taxFee = 4;
    uint256 private _previousTaxFee = _taxFee;	
    	
    uint256 public _liquidityFee = 1;	
    uint256 private _previousLiquidityFee = _liquidityFee;	
    
    uint256 public _lottoFee = 2;
    uint256 private _previousLottoFee = _lottoFee;
	
	uint256 public _devFee = 1;
    uint256 private _previousDevFee = _devFee;
    
    IUniswapV2Router02 public uniswapV2Router;	
    address public uniswapV2Pair;	
    	
    bool inSwapAndLiquify;	
    bool inLotteryDraw;	
    bool public swapAndLiquifyEnabled = true;	
    bool public lottoEnabled = true;
    bool public _shouldSwapToBNB = false;
    
    uint256 public _maxTxAmount = 100000 * 10**12 * 10**9;
    uint256 private numTokensSellToAddToLiquidity = 500 * 10**12 * 10**9;	
    uint256 public lotteryThreshold = 10 * 10**12 * 10**9;	
    // anti whale
    bool    public _isAntiWhaleEnabled = true;
    uint256 public _antiWhaleThreshold = 1 * 10**15 * 10**9;
    
    struct TData {
        uint256 tAmount;
        uint256 tFee;
        uint256 tLiquidity;
        uint256 tLotto;
        uint256 tDev;
        uint256 currentRate;
    }
    
    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);	
    event SwapAndLiquifyEnabledUpdated(bool enabled);	
    event SwapAndLiquify(	
        uint256 tokensSwapped,	
        uint256 ethReceived,	
        uint256 tokensIntoLiqudity	
    );
    event DrawLotto(uint256 amount, uint _lottoDrawCount);
    	
    modifier lockTheSwap {	
        inSwapAndLiquify = true;	
        _;	
        inSwapAndLiquify = false;	
    }
    
    modifier lockTheLottery {	
        inLotteryDraw = true;	
        _;	
        inLotteryDraw = false;	
    }
    
    constructor () {
        _rOwned[_msgSender()] = _rTotal;	
        addAddress(_msgSender());
        _lottoPotAddress = address(1);
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);	
         // Create a uniswap pair for this new token	
        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())	
            .createPair(address(this), _uniswapV2Router.WETH());	
        // set the rest of the contract variables	
        uniswapV2Router = _uniswapV2Router;	
        	
        //exclude owner and this contract from fee	
        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[_lottoPotAddress] = true;
        _isExcludedFromFee[address(this)] = true;	
        
        _isExcludedFromAntiWhale[owner()] = true;
        _isExcludedFromAntiWhale[_lottoPotAddress] = true;
        _isExcludedFromAntiWhale[address(this)] = true;
        _isExcludedFromAntiWhale[address(uniswapV2Router)] = true;
        _isExcludedFromAntiWhale[uniswapV2Pair] = true;
        	
        emit Transfer(address(0), _msgSender(), _tTotal);	
    }	
    function name() public view returns (string memory) {	
        return _name;	
    }	
    function symbol() public view returns (string memory) {	
        return _symbol;	
    }	
    function decimals() public view returns (uint8) {	
        return _decimals;	
    }	
    function totalSupply() public view override returns (uint256) {	
        return _tTotal;	
    }
    function minLottoBalance() public view returns (uint256) {	
        return _minLottoBalance;	
    }
    function currentLottoPool() public view returns (uint256) {	
        return balanceOf(_lottoPotAddress);	
    }
    function balanceOf(address account) public view override returns (uint256) {	
        if (_isExcluded[account]) return _tOwned[account];	
        return tokenFromReflection(_rOwned[account]);	
    }	
    function transfer(address recipient, uint256 amount) public override returns (bool) {	
        _transfer(_msgSender(), recipient, amount);	
        return true;	
    }	
    function allowance(address owner, address spender) public view override returns (uint256) {	
        return _allowances[owner][spender];	
    }	
    function approve(address spender, uint256 amount) public override returns (bool) {	
        _approve(_msgSender(), spender, amount);	
        return true;	
    }	
    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {	
        _transfer(sender, recipient, amount);	
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "BEP20: transfer amount exceeds allowance"));	
        return true;	
    }	
    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {	
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));	
        return true;	
    }	
    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {	
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "BEP20: decreased allowance below zero"));	
        return true;	
    }	
    function isExcludedFromReward(address account) public view returns (bool) {	
        return _isExcluded[account];	
    }	
    function totalFees() public view returns (uint256) {	
        return _tFeeTotal;	
    }	
    function deliver(uint256 tAmount) public {	
        address sender = _msgSender();	
        require(!_isExcluded[sender], "Excluded addresses cannot call this function");	
        (uint256 rAmount,,,,,,,) = _getValues(tAmount);	
        _rOwned[sender] = _rOwned[sender].sub(rAmount);	
        _rTotal = _rTotal.sub(rAmount);	
        _tFeeTotal = _tFeeTotal.add(tAmount);	
    }	
    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {	
        require(tAmount <= _tTotal, "Amount must be less than supply");	
        if (!deductTransferFee) {	
            (uint256 rAmount,,,,,,,) = _getValues(tAmount);	
            return rAmount;	
        } else {	
            (,uint256 rTransferAmount,,,,,,) = _getValues(tAmount);	
            return rTransferAmount;	
        }	
    }	
    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {	
        require(rAmount <= _rTotal, "Amount must be less than total reflections");	
        uint256 currentRate =  _getRate();	
        return rAmount.div(currentRate);	
    }	
    function excludeFromReward(address account) public onlyOwner() {	
        // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');	
        require(!_isExcluded[account], "Account is already excluded");	
        if(_rOwned[account] > 0) {	
            _tOwned[account] = tokenFromReflection(_rOwned[account]);	
        }	
        _isExcluded[account] = true;	
        _excluded.push(account);	
    }	
    function includeInReward(address account) external onlyOwner() {	
        require(_isExcluded[account], "Account is already excluded");	
        for (uint256 i = 0; i < _excluded.length; i++) {	
            if (_excluded[i] == account) {	
                _excluded[i] = _excluded[_excluded.length - 1];	
                _tOwned[account] = 0;	
                _isExcluded[account] = false;	
                _excluded.pop();	
                break;	
            }	 
        }	
    }
    
    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {	
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tLotto, uint256 tDev) = _getValues(tAmount);	
        _tOwned[sender] = _tOwned[sender].sub(tAmount);	
        _rOwned[sender] = _rOwned[sender].sub(rAmount);	
        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);	
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        	
        _takeLiquidity(tLiquidity);	
        _takeLotto(tLotto);
		_takeDev(tDev);
        _reflectFee(rFee, tFee);	
        emit Transfer(sender, recipient, tTransferAmount);	
    }	
    
    function setUniswapRouter(address r) external onlyOwner {
        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(r);
        uniswapV2Router = _uniswapV2Router;
    }

    function setUniswapPair(address p) external onlyOwner {
        uniswapV2Pair = p;
    }
    function excludeFromFee(address account) public onlyOwner {	
        _isExcludedFromFee[account] = true;	
    }	
    	
    function includeInFee(address account) public onlyOwner {	
        _isExcludedFromFee[account] = false;	
    }	
    	
    function setTaxFeePercent(uint256 taxFee) external onlyOwner() {	
        _taxFee = taxFee;	
    }	
    
    function setLottoFeePercent(uint256 lottoFee) external onlyOwner() {
        _lottoFee = lottoFee;
    }

	function setDevFeePercent(uint256 devFee) external onlyOwner() {
        _devFee = devFee;
    }
    
    function setshouldSwapToBNB(bool enabled) public onlyOwner() {
        _shouldSwapToBNB = enabled;
    }
    function setLottoEnabled(bool enabled) public onlyOwner() {
        lottoEnabled = enabled;
    }
    function setDevAddress(address payable dev) public onlyOwner() {
        _devWallet = dev;
    }
	function setMinLottoBalance(uint256 minBalance) public onlyOwner() {
        _minLottoBalance = minBalance;
    }
	function setLotteryThresHold(uint256 threshold) public onlyOwner() {
        lotteryThreshold = threshold;
    }
    function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {	
        _liquidityFee = liquidityFee;	
    }	
    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {	
        _maxTxAmount = _tTotal.mul(maxTxPercent).div(	
            10**2	
        );	
    }	
    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {	
        swapAndLiquifyEnabled = _enabled;	
        emit SwapAndLiquifyEnabledUpdated(_enabled);	
    }	
    function setAntiWhaleEnabled(bool e) external onlyOwner {
        _isAntiWhaleEnabled = e;
    }
    function setAntiWhaleThreshold(uint256 amount) external onlyOwner {
        _antiWhaleThreshold = amount;
    }
    function setExcludedFromAntiWhale(address account, bool e) external onlyOwner {
        _isExcludedFromAntiWhale[account] = e;
    }
     //to recieve ETH from uniswapV2Router when swaping	
    receive() external payable {}	
    function _reflectFee(uint256 rFee, uint256 tFee) private {	
        _rTotal = _rTotal.sub(rFee);	
        _tFeeTotal = _tFeeTotal.add(tFee);	
    }	
    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256) {	
        (uint256 tTransferAmount, TData memory data) = _getTValues(tAmount);
        data.tAmount = tAmount;
        data.currentRate = _getRate();
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(data);	
        return (rAmount, rTransferAmount, rFee, tTransferAmount, data.tFee, data.tLiquidity, data.tLotto, data.tDev);	
    }	
    function _getTValues(uint256 tAmount) private view returns (uint256, TData memory) {	
        uint256 tFee = calculateTaxFee(tAmount);	
        uint256 tLiquidity = calculateLiquidityFee(tAmount);	
        
        uint256 tLotto = calculateLottoFee(tAmount);
		uint256 tDev = calculateDevFee(tAmount);
		
        uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity).sub(tLotto).sub(tDev);	
        return (tTransferAmount, TData(0, tFee, tLiquidity, tLotto, tDev, 0));	
    }	
    function _getRValues(TData memory _data) private pure returns (uint256, uint256, uint256) {	
        uint256 rAmount = _data.tAmount.mul(_data.currentRate);	
        uint256 rFee = _data.tFee.mul(_data.currentRate);	
        uint256 rLiquidity = _data.tLiquidity.mul(_data.currentRate);	
        uint256 rLotto = _data.tLotto.mul(_data.currentRate);
		uint256 rDev = _data.tDev.mul(_data.currentRate);
        uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity).sub(rLotto).sub(rDev);	
        return (rAmount, rTransferAmount, rFee);	
    }	
    function _getRate() private view returns(uint256) {	
        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();	
        return rSupply.div(tSupply);	
    }	
    function _getCurrentSupply() private view returns(uint256, uint256) {	
        uint256 rSupply = _rTotal;	
        uint256 tSupply = _tTotal;      	
        for (uint256 i = 0; i < _excluded.length; i++) {	
            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);	
            rSupply = rSupply.sub(_rOwned[_excluded[i]]);	
            tSupply = tSupply.sub(_tOwned[_excluded[i]]);	
        }	
        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);	
        return (rSupply, tSupply);	
    }	
    
	function addAddress(address adr) private {
        if(_AddressExists[adr])
            return;
        _AddressExists[adr] = true;
        _addressList.push(adr);
    }
    
    function random() private view returns (uint) {
        // sha3 and now have been deprecated
        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, block.number)));
        // convert hash to integer
    }
    	
    function lotterize() private view returns(address) {
		uint256 randomNumber = random().mod(_addressList.length);

		uint256 ownedAmount = _rOwned[_addressList[randomNumber]];

		if (ownedAmount >= _minLottoBalance) {
			return _addressList[randomNumber];
		}
		return _devWallet;
    }
    
    function _takeLotto(uint256 tLotto) private {
        uint256 currentRate =  _getRate();
        uint256 rLotto = tLotto.mul(currentRate);

        _rOwned[_lottoPotAddress] = _rOwned[_lottoPotAddress].add(rLotto);
        if(_isExcluded[_lottoPotAddress])
            _tOwned[_lottoPotAddress] = _tOwned[_lottoPotAddress].add(tLotto);
    }
    
    function drawLotto(uint256 amount) private lockTheLottery {
        _lottoWalletAddress = lotterize();
        _transfer(_lottoPotAddress, _lottoWalletAddress, amount);
        _lastLottoWinnerAmount = amount;
        _totalLottoPrize = _totalLottoPrize.add(amount);
        ++_lottoDrawCount;
        emit DrawLotto(amount, _lottoDrawCount);
    }
    
    function _takeDev(uint256 tDev) private {
        uint256 currentRate =  _getRate();
        uint256 rDev = tDev.mul(currentRate);

        if (_shouldSwapToBNB) {
            swapTokensForEth(rDev);
            _devWallet.transfer(address(this).balance);
        } else {
            _rOwned[_devWallet] = _rOwned[_devWallet].add(rDev);
            if(_isExcluded[_devWallet])
                _tOwned[_devWallet] = _tOwned[_devWallet].add(tDev);
        }
    }
    
    function _takeLiquidity(uint256 tLiquidity) private {	
        uint256 currentRate =  _getRate();	
        uint256 rLiquidity = tLiquidity.mul(currentRate);	
        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);	
        if(_isExcluded[address(this)])	
            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);	
    }	
    	
    	
    function calculateLottoFee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_lottoFee).div(
            10**2
        );
    }
	
	function calculateDevFee(uint256 _amount) private view returns (uint256) {
        return _amount.mul(_devFee).div(
            10**2
        );
    }
    
    function calculateTaxFee(uint256 _amount) private view returns (uint256) {	
        return _amount.mul(_taxFee).div(	
            10**2	
        );	
    }	
    function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {	
        return _amount.mul(_liquidityFee).div(	
            10**2	
        );	
    }
    
    function removeAllFee() private {	
        if(_taxFee == 0 && _liquidityFee == 0 && _devFee == 0 && _lottoFee == 0) return;	
        	
        _previousTaxFee = _taxFee;
        _previousLottoFee = _lottoFee;
		_previousDevFee = _devFee;
        _previousLiquidityFee = _liquidityFee;
        	
        _taxFee = 0;
        _lottoFee = 0;
		_devFee = 0;
        _liquidityFee = 0;	
    }	
    	
    function restoreAllFee() private {	
        _taxFee = _previousTaxFee;	
        _lottoFee = _previousLottoFee;
		_devFee = _previousDevFee;
        _liquidityFee = _previousLiquidityFee;	
    }	
    	
    function isExcludedFromFee(address account) public view returns(bool) {	
        return _isExcludedFromFee[account];	
    }	
    
    function _approve(address owner, address spender, uint256 amount) private {	
        require(owner != address(0), "BEP20: approve from the zero address");	
        require(spender != address(0), "BEP20: approve to the zero address");	
        _allowances[owner][spender] = amount;	
        emit Approval(owner, spender, amount);	
    }	
    function _transfer(	
        address from,	
        address to,	
        uint256 amount	
    ) private {	
        require(from != address(0), "BEP20: transfer from the zero address");	
        require(to != address(0), "BEP20: transfer to the zero address");	
        require(amount > 0, "Transfer amount must be greater than zero");	
        if(from != owner() && to != owner())	
            require(amount <= _maxTxAmount, "Transfer amount exceeds the maxTxAmount.");	
            
        /*
            anti whale: when buying, check if sender balance will be greater than 1% of total supply
            if greater, throw error
        */
        if ( _isAntiWhaleEnabled && !_isExcludedFromAntiWhale[to] ) {
            if ( from == uniswapV2Pair || from == address(uniswapV2Router) ) {
                require(amount <= _antiWhaleThreshold, "Anti whale: can't buy more than the specified threshold");
                require(balanceOf(to).add(amount) <= _antiWhaleThreshold, "Anti whale: can't hold more than the specified threshold");
            }
        }
        // is the token balance of this contract address over the min number of	
        // tokens that we need to initiate a swap + liquidity lock?	
        // also, don't get caught in a circular liquidity event.	
        // also, don't swap & liquify if sender is uniswap pair.	
        uint256 contractTokenBalance = balanceOf(address(this));	
        	
        if(contractTokenBalance >= _maxTxAmount)	
        {	
            contractTokenBalance = _maxTxAmount;	
        }	
        	
        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;	
        if (	
            overMinTokenBalance && !inSwapAndLiquify &&	from != uniswapV2Pair && swapAndLiquifyEnabled	
        ) {	
            contractTokenBalance = numTokensSellToAddToLiquidity;	
            //add liquidity	
            swapAndLiquify(contractTokenBalance);	
        }
        
        // Process lotto draw
        uint256 lottoBalance = balanceOf(_lottoPotAddress);
        bool overMinLottoBalance = lottoBalance >= lotteryThreshold;
        if (
            overMinLottoBalance && !inSwapAndLiquify && !inLotteryDraw && lottoEnabled
        ) {
            drawLotto(lottoBalance);
        }
        	
        //indicates if fee should be deducted from transfer	
        bool takeFee = true;	
        	
        //if any account belongs to _isExcludedFromFee account then remove the fee	
        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){	
            takeFee = false;	
        }	
        
        addAddress(from);
		addAddress(to);
        	
        //transfer amount, it will take tax, burn, liquidity fee	
        _tokenTransfer(from,to,amount,takeFee);	
    }	
    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {	
        // split the contract balance into halves	
        uint256 half = contractTokenBalance.div(2);	
        uint256 otherHalf = contractTokenBalance.sub(half);	
        // capture the contract's current ETH balance.	
        // this is so that we can capture exactly the amount of ETH that the	
        // swap creates, and not make the liquidity event include any ETH that	
        // has been manually sent to the contract	
        uint256 initialBalance = address(this).balance;	
        // swap tokens for ETH	
        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered	
        // how much ETH did we just swap into?	
        uint256 newBalance = address(this).balance.sub(initialBalance);	
        // add liquidity to uniswap	
        addLiquidity(otherHalf, newBalance);	
        	
        emit SwapAndLiquify(half, newBalance, otherHalf);	
    }	
    function swapTokensForEth(uint256 tokenAmount) private {	
        // generate the uniswap pair path of token -> weth	
        address[] memory path = new address[](2);	
        path[0] = address(this);	
        path[1] = uniswapV2Router.WETH();	
        _approve(address(this), address(uniswapV2Router), tokenAmount);	
        // make the swap	
        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(	
            tokenAmount,	
            0, // accept any amount of ETH	
            path,	
            address(this),	
            block.timestamp	
        );	
    }	
    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {	
        // approve token transfer to cover all possible scenarios	
        _approve(address(this), address(uniswapV2Router), tokenAmount);	
        // add the liquidity	
        uniswapV2Router.addLiquidityETH{value: ethAmount}(	
            address(this),	
            tokenAmount,	
            0, // slippage is unavoidable	
            0, // slippage is unavoidable	
            owner(),	
            block.timestamp	
        );	
    }	
    //this method is responsible for taking all fee, if takeFee is true	
    function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {	
        if(!takeFee)	
            removeAllFee();	
        	
        if (_isExcluded[sender] && !_isExcluded[recipient]) {	
            _transferFromExcluded(sender, recipient, amount);	
        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {	
            _transferToExcluded(sender, recipient, amount);	
        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {	
            _transferStandard(sender, recipient, amount);	
        } else if (_isExcluded[sender] && _isExcluded[recipient]) {	
            _transferBothExcluded(sender, recipient, amount);	
        } else {	
            _transferStandard(sender, recipient, amount);	
        }	
        	
        if(!takeFee)	
            restoreAllFee();	
    }	
    function _transferStandard(address sender, address recipient, uint256 tAmount) private {	
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tLotto, uint256 tDev) = _getValues(tAmount);	
        _rOwned[sender] = _rOwned[sender].sub(rAmount);	
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);	
        _takeLiquidity(tLiquidity);	
        _takeLotto(tLotto);
		_takeDev(tDev);
        _reflectFee(rFee, tFee);	
        emit Transfer(sender, recipient, tTransferAmount);	
    }	
    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {	
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tLotto, uint256 tDev) = _getValues(tAmount);	
 _rOwned[remetente] = _rOwned[remetente]. sub(rAmount); 
 _tOwned[destinatário] = _tOwned[destinatário]. adicionar(tTransferAmount); 
 _rOwned[destinatário] = _rOwned[destinatário]. adicionar(rTransferAmount); 
        _takeLiquidity(tLiquidity);	
        _takeLotto(tLotto);
		_takeDev(tDev);
        _reflectFee(rFee, tFee);	
        emitir Transferência(remetente, destinatário, tTransferAmount); 
    }	
    função _transferFromExcluded (remetente deendereço, destinatário de endereços , uint256 tAmount) privado {	
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity, uint256 tLotto, uint256 tDev) = _getValues(tAmount);	
 _tOwned[remetente] = _tOwned[remetente]. sub(tAmount); 
 _rOwned[remetente] = _rOwned[remetente]. sub(rAmount); 
 _rOwned[destinatário] = _rOwned[destinatário]. adicionar(rTransferAmount); 
        _takeLiquidity(tLiquidity);	
        _takeLotto(tLotto);
		_takeDev(tDev);
        _reflectFee(rFee, tFee);	
        emitir Transferência(remetente, destinatário, tTransferAmount);
